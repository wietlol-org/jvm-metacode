// hash: #ce09a818
// @formatter:off

package metacode.core.parser.data.models

import metacode.api.parser.data.models.*

// Generated by BitBlock version 1.0.0

// @formatter:on
// @tomplot:customCode:start:B8CiSn

import metacode.api.lexer.MetaCodeToken
import metacode.api.parser.context.MatchContext
import metacode.api.parser.results.RuleResult

// @tomplot:customCode:end
// @formatter:off

data class DefaultPriorityTreeRule(
	override val name: String,
	override val options: List<PriorityTreeRuleOption>,
) : PriorityTreeRule
{
	override fun equals(other: Any?): Boolean =
		isEqualTo(other)
	
	override fun hashCode(): Int =
		computeHashCode()
	
	override fun toString(): String =
		toJson()
	
	override fun duplicate(): DefaultPriorityTreeRule =
		copy(
			name = name,
			options = options.map { it.duplicate() }.toMutableList(),
		)
	
	// @formatter:on
	// @tomplot:customCode:start:fIpaBB
	
	/*
	expression
		: .9 -> expressions=expression ('|' expressions=>expression){1,}	#anyOfExpression
		
		| .8 -> expressions=>expression{1,}									#sequenceExpression
		
		| .7 -> expression=>expression '?'									#optionalExpression
		
		| .6 -> expression=>expression '{' minimumMatches=&number ',' '}'	#repeatingExpression
		
		| .5 -> label=&identifier '=' expression=>expression				#labelledExpression
		
		| .1 -> prefix=('<' | '>')? name=&identifier						#ruleExpression
		| .1 -> '&' name=&identifier										#typeExpression
		| .1 -> '(' expression=<expression ')'								#enclosedExpression
		| .1 -> value=&literal												#literalExpression
		;
	*/
	override fun compileTree(): Collection<ParserRule>
	{
		val groups = options
			.groupBy { it.priority }
			.toList()
			.sortedByDescending { it.first }
		
		val max = groups.size - 1
		
		return groups
			.mapIndexed { index, it ->
				DefaultMultiOptionRule(
					if (index == 0) name else "${name}_$index",
					it.second.map {
						DefaultRuleOption(
							it.name,
							it.expression.copy(index)
						)
					}
						.let {
							if (index < max)
								it.plus(DefaultRuleOption(
									"_next",
									DefaultLabelledParserExpression(
										"_next",
										DefaultRuleParserExpression(
											"${name}_${index + 1}"
										)
									)
								))
							else it
						}
				)
			}
	}
	
	override fun findMatches(context: MatchContext, tokens: List<MetaCodeToken>, fromIndex: Int): Sequence<RuleResult>
	{
		TODO("Not yet implemented")
	}
	
	override fun isLeftRecursiveTo(context: MatchContext, name: CharSequence): Boolean
	{
		TODO("Not yet implemented")
	}
	
	private fun ParserExpression.copy(index: Int): ParserExpression =
		when (this)
		{
			is AnyOfParserExpression -> DefaultAnyOfParserExpression(expressions.map { it.copy(index) })
			is LabelledParserExpression -> DefaultLabelledParserExpression(label, expression.copy(index))
			is LiteralParserExpression -> DefaultLiteralParserExpression(query)
			is OptionalParserExpression -> DefaultOptionalParserExpression(expression.copy(index), isGreedy)
			is RepeatingParserExpression -> DefaultRepeatingParserExpression(expression.copy(index), minimumMatches, isGreedy)
			is RuleParserExpression -> when (prefix)
			{
				"<" -> DefaultRuleParserExpression(if (index > 0) "${ruleName}_$index" else ruleName)
				">" -> DefaultRuleParserExpression("${ruleName}_${index + 1}")
				else -> DefaultRuleParserExpression(ruleName)
			}
			is SequenceParserExpression -> DefaultSequenceParserExpression(expressions.map { it.copy(index) })
			is TypeParserExpression -> DefaultTypeParserExpression(typeName)
			is WildcardParserExpression -> DefaultWildcardParserExpression()
			else -> throw UnsupportedOperationException("Unsupported operation copy on type ${javaClass.name}.")
		}
	
	// @tomplot:customCode:end
	// @formatter:off
}
// @formatter:on
